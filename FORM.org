* PitayaForm

*PitayaForm* defines a data representation that provides a framework
for collecting data from a user interface and converting it to the
desired data model.

The current specification is based on JSON [[[https://datatracker.ietf.org/doc/html/rfc8259][RFC 8259]]] or other
interchangeable formats like [[https://yaml.org/][YAML]], although any data serialization
format with [[https://datatracker.ietf.org/doc/html/rfc8259#section-3][JSON basic data types]] could be used in the same way.

* Conventions Used in This Document

Most examples in this document are in YAML format because it's a
little more readable than the equivalent JSON.

The key words "MUST," "MUST NOT," "REQUIRED," "SHALL," "SHALL NOT,"
"SHOULD," "SHOULD NOT," "RECOMMENDED," and "MAY," in this document are
to be interpreted as described in [[[https://datatracker.ietf.org/doc/html/rfc2119][RFC 2119]]] [[[https://datatracker.ietf.org/doc/html/rfc8174][RFC 8174]]].

Other terms are defined below:

- PitayaForm :: The JSON document defining the OBJECT which can be
  used by the frontend to be rendered as a form user interface.

- frontend :: The front-end system that can render a user interface,
  collect the input data from the user and convert it to the target
  data model.

- backend :: The back-end system which submit a PitayaForm to the
  frontend and accept its target data model.

- BASIC DATATYPES :: JSON basic data types i.e. object, array, string,
  number, boolean and the literal =null=.

- OBJECT :: The JSON object basic data type

- ARRAY :: The JSON array basic data type

- STRING :: The JSON string basic data type

- NUMBER :: The JSON number basic data type

- BOOLEAN :: The JSON boolean basic data type which can be =true= or
  =false=

- NULL LITERAL :: The JSON =null= literal

- REQUIRED :: A key/value in an OBJECT or a value in an ARRAY that
  MUST be provided for a PitayaForm to be valid.

- OPTIONAL :: A key/value in an OBJECT or a value in an ARRAY that MAY
  be provided for a PitayaForm, nevertheless if not provided, the form
  still is valid.

- FRONTEND OPTIONAL :: A feature that is optional for a frontend to
  implement.

- target data model :: The final data generated by the frontend after
  collecting the user input that should be passed to the backend.

* Overview

A PitayaForm basically describes a form-based user interface. Each
field in the form MUST have a specific data type compatible with BASIC
DATAYPES.

A compatible data type could be structured from BASIC DATATYPES. For a
example a =File= type MAY be used as an OBJECT with a STRING
=filename= and a base64 encoded STRING =content=:

#+begin_src js
{"filename": "file.txt", "content": "cGl0YXlh"}
#+end_src

The data types are not defined in this document, intentionally. They
may be defined in other documents but here it is supposed that each
data type can be gathered with the proper UI widget by the frontend
and the frontend knows how to convert the input data to the desired
format.

The emphasis of this document is on the user experience in a UI from
and a extendable format to add details. But the details themselves
such as the styles or arrangement of the elements are deliberately
left to other documents.

Each PitayaForm MUST be defined as an OBJECT with the keys described
below.

* =version=

The =version= key defines the current PitayaForm version. It is
currently the STRING "1". It is a REQUIRED key and MUST be present in
a PitayaForm description.

On examples in this document the =version= key is removed from the
documents for brevity, nevertheless in practice it is mandatory.

* =form=

The =form= is an OBJECT which defines the fields of the
PitayaForm. The keys in the =form= must be at least one character and
only contains ASCII alphabet, numbers or underscore characters. In
other words they should match the =\w+= Perl regular expression.

Each key is a unique name that will be used both as a reference for
the field in the PitayaForm and it will be used as the unique key of
the collected data in the target data model. Here is an example:

#+name: A simple form with options
#+begin_src yaml
  form:
    device_name:
      name: Device Name
      type: String
      order: 0
    temperature:
      name: Temperature
      type: Number
      options:
        float: true
        signed: true
      order: 1
#+end_src

The above form can be rendered to the following user interface by the
frontend:

[[./images/form-options.png]]

Finally, the frontend can generate a target data model according to
the user input data:

#+name: taget data model for the sample form
#+begin_src js
{"device_name": "", "temperature": 19.3}
#+end_src

The following keys MAY be available in the fields of the =form=.

** =name=

OPTIONAL. A human readable short name that the frontend SHOULD show the
user for the field. IF not present, the frontend SHOULD use the unique
key reference of the field.

The =name= could also be NULL LITERAL in which case the field label
MUST be omitted in the user interface.

It is RECOMMENDED that the frontend show at least 30 characters of the
=name=. Extra characters MAY replaced by an ellipsis.

** =description=

OPTIONAL. A human readable text describing the field or add more
details about how the user may enter the required input.

FRONTEND OPTIONAL. A frontend MAY implement this feature and provide
this information for the field as a small text under the field, a
tool-tip or any other way, or if not support it, the frontend may
ignore it.

It is RECOMMENDED that the frontend show at least 120 characters of
the =description=. Extra characters MAY replaced by an ellipsis.

** =long_description=

OPTIONAL. FRONTEND OPTIONAL. Just like =description= but without a
RECOMMENDED length. It is RECOMMENDED that frontends support both
description and long description together but show them in different
ways.

It is also RECOMMENDED that the frontend provide a way for the user to
view the whole =long_description= text. This might be happen by using
a scroll-bar.

** =type=

OPTIONAL. The data type of the field. It could be BASIC DATATYPES or
the structured data types based on them. Its default value is STRING.

Each frontend MAY implement a sub-set of data types. This document
intentionally left the data types specification for other documents,
but it is supposed that the frontend may use specialized widgets for
each data type.

This document also uses =Label= and =Submit= as data types, both of
them without any value. =Label= is for adding read-only labels in a
form and =Submit= to add a button, useful for defining =actions=.

** =default=

OPTIONAL. The default value for the field that if the user didn't
entered a value it MUST be used as the value in the target data
model. The default value may have a non-compatible data type. E.g. A
field may be STRING but the default value may be a NUMBER or NULL
LITERAL.

The non-compatible data types are useful for the backend to detect if
a field left untouched by user, although the frontend may not provide
a way for the user to go back to the default non-compatible type value
if the user entered a value.

The frontend may also show the the default value to the user but it is
up to the frontend.

The default value of each data type MAY also be specified, otherwise
NULL LITERAL MUST be assumed. When the user dose not provide an input
for a field and there is no =default=, the FRONTEND MUST use the
default value of its type.

The default value for STRING is an empty string, for NUMBER is =0=,
for BOOLEAN is =false= and for ARRAY is an empty array =[]=, for other
structured types is NULL unless the type documentation specifies
something else.

** =array=

OPTIONAL. A BOOLEAN value that defaults to =false=.

If =array= is =true= the FRONEND MUST accept an array of the fields of
the data type and generate an ARRAY for the target data model.

In this case the =default= MUST also be an ARRAY.

Here is an example of =array=:

#+name: simple arrays example
#+begin_src yaml
  form:
    title:
      name: Title
      type: String
    rows:
      name: Rows
      type: String
      array: true
      default:
        - foo
        - bar
#+end_src

[[./images/simple-array.png]]

#+name: simple arrays result values example
#+begin_src yaml
  title: "This is the Title"
  rows:
    - foo
    - bar
#+end_src

** =gid=

OPTIONAL. A group ID for the field that MUST match the =\w+= Perl
regular expression just like the field reference keys. Also a =gid=
MUST not be the same as a filed key reference.

The fields that share a =gid= are in a logical group. The frontend MAY
use the logical groups to provide better appearance for the form.

The default value for =gid= if not provided, MUST be considered
=_root=, so the =styles= could be added to logical =_root= group.

** =order=

OPTIONAL.

The JSON specification states that OBJECTs are an unordered set of
items. So if the order of the fields in the user interface is a
requirement an optional =order= MAY be used to sort the fields in
ascending order.

Although some implementation may support the OBJECT order. In that
case the frontend SHOULD preserve the order.

The =order= specifies the field order in its logical group defined by
its =gid=.

** =options=

OPTIONAL. Extra options for the field and its data type that specify
the detailed information about how the data should be interpreted or
what is valid or invalid.

The documentation for data types may provide more information about
the options for each data type. For example a NUMBER may be
interpreted as an integer or a floating point with the =float= option,
or =choices= for a combo box may provide the items for the user to
choose from.

Some options MAY also be available for all the data
types. =validators= MAY be used to define more customized validation.

*** =validators=

OPTIONAL. An ARRAY of validators that MAY be used by the frontend or
backend or both to verify if the entered value is valid.

FRONTEND OPTIONAL. A frontend MAY not implement this feature and leave
it for the backend as is.

Each validator may provide a hint which the frontend MAY use to guide
the user to enter a valid data.

The validators specification are not described in this document and
other documents could focus on that. But here is an example for a
simple implementation:

#+name: validators example
#+begin_src yaml
  name: URL
  default: "https://example.org/v1/"
  type": String
  options:
    validators:
      - allow_null: true
      - hint: "A valid URL (http/https) is required."
        url: true
        url_schemes:
          - http
          - https
      - hint": "Only API v1 is supported."
        regex: ".*/v1/.*"
#+end_src

** =events=

OPTIONAL. An OBJECT. The keys are the name of the event and the value
for each event is an ARRAY of references to actions defined in the
=actions= section that a frontend MAY execute them in the mentioned
order if it support the event.

FRONTEND OPTIONAL. A frontend may support any events but they are not
specified in this document.

* =styles=

An OPTIONAL =styles= may be provided for each PitayaForm in which keys
are references to fields and groups and the values are OBJECTs that
add styles to the references that MAY be supported by the frontend.

Valid =styles= are not defined in this document but it is supposed
that =styles= will not affect the interpretation or validation of data
(as it is the job of the =options= in =form= section) and MAY only
change the appearance of the UI.

For example, if new line character is acceptable for the type STRING,
a =multiline= style MAY indicate to show a multi-line text box or a
single line one, although in both cases the user may be able to
provide a text with new line character.

=styles= may also be used to change the arrangement of items in a
group, for example to arrange widgets in columns.

Another FRONTEND OPTIONAL feature is that the forntend MAY support
changing the style of single item in an array by using [[https://goessner.net/articles/JsonPath/][jsonpath]] like
references:

#+name: jsonpath references example in styles
#+begin_src yaml
  form:
    url:
      name: URL
      type: String
      array: true
  styles:
    url:
      placeholder: http://foo
    url[2]:
      placeholder: http://bar
#+end_src

In the above example, all URLs in the array will have the "http://foo"
as the =placeholder=, except the third item of the array which will
have "http://bar" as the =placeholder=.

* =groups=

As described in the =gid= section, sharing =gid= for the fields will
put them in a logical group that can be used for the frontend to use
this data for changing the appearance.

For example a frontend MAY put the fields of each group in a single
row.

#+name: simple group example
#+begin_src yaml
  form:
    url:
      name: URL
      type: String
      order: 0
    key:
      name: Key
      type: String
      gid: header
      order: 0
    value:
      name: Value
      type: String
      gid: header
      order: 1
#+end_src

[[./images/groups-simple.png]]

But groups can be used for other purposes through the =groups=
section.

The =groups= key defines an OBJECT in which each key is a reference to
a =gid= or a non-existent logical group. Non-existent logical group
keys MUST also abide the =gid= naming conventions.

The =groups= can be used to change the place where the data will be
stored in the target data model. In the above example the target data
model could be as follows:

#+name: target data model without groups sections
#+begin_src yaml
  url: "http://example.com"
  key: "Content-Type"
  value: "plain/text"
#+end_src

But adding a =groups= section with an empty OBJECT for the =header=
group can change the data model:

#+name: groups section example
#+begin_src yaml
  form:
    url:
      name: URL
      type: String
      order: 0
    key:
      name: Key
      type: String
      gid: header
      order: 0
    value:
      name: Value
      type: String
      gid: header
      order: 1
  groups:
    header: {}
#+end_src

Now the data model would be like this:

#+name: target data model without groups sections
#+begin_src yaml
  url: "http://example.com"
  header:
    key: "Content-Type"
    value: "plain/text"
#+end_src

Each group in the =groups= section could also add extra options to the
referred logical group that we explore below.

** =name=

OPTIONAL. FRONTEND OPTIONAL. A human readable short name for the group
that if frontend support, it may showed for the group.

** =description=

OPTIONAL. A human readable text describing the group or add more
details about how the user may enter the required values in the group.

FRONTEND OPTIONAL. A frontend MAY implement this feature and provide
this information for the group as a tool-tip or any other way, or if
not support it, the frontend may ignore it.

** =target_group=

OPTIONAL. The =target_group= MAY be used to change the key in the
target data model for the group.

In the above example adding a =target_group= can be added to the
=header=:

#+name: groups section example with target_group
#+begin_src yaml
  groups:
    header:
      target_group: key_value_pair
#+end_src

Now the data model would be like this:

#+name: target data model without groups sections
#+begin_src yaml
  url: "http://example.com"
  key_value_pair:
    key: "Content-Type"
    value: "plain/text"
#+end_src

The special NULL LITERAL if used as the value for the =target_group=,
it means that the group has no effect in the data model and the
related fields must be stored in the target data model as if they have
no =gid=.

Note that the default value for =target_group= when it is not present
is the group reference itself not the NULL LITERAL.

The default =_root= for =gid= without a =target_group=, if defined in
the =groups= section will not result in changing the data model, but
with a =target_group= other than NULL LITERAL it can be used to put
the whole data model in the given key.

** =order=

OPTIONAL. The =order= in the =gourps= is just like the =order= in the
=form= section, but it MAY be used to change the order of groups among
other groups and fields.

** =array=

OPTIONAL. A BOOLEAN value. A group MAY be an array with the exact same
syntax as =array= in the =form= section.

Here is an example:

#+name: array group example
#+begin_src yaml
  form:
    url:
      name: URL
      type: String
      order: 0   # (A) in NOTE*
    key:
      name: Key
      type: String
      gid: header
      order: 0   # (B) in NOTE*
    value:
      name: Value
      type: String
      gid: header
      order: 1
  groups:
    header:
      name: "Header"
      description: |
        Any valid HTTP header can be provided. Note that the
        keys has to be Latin-1 encoded.
      array: true
      target_group: headers
      order: 1  # (C) in NOTE*
  styles:  # styles can be adde to both field and group references
    value:
      multiline: true
    header:
      border: true

  # NOTE*: the defined orders has the following effects:
  #
  # - (A) means that url is before the header group with 1 as order
  # - (B) means key is before value in the header group.
  # - (C) means the header group will be after the url field with 0 as order
#+end_src

[[./images/groups-array.png]]

#+name: array group example target data model
#+begin_src yaml
  url: "http://example.com"
  headers:
    - key: Content-Type
      value: application/json
    - key: Content-Length
      value: "1000"
#+end_src

** =default=

OPTIONAL. If a group is defined as an =array=, the =default= ARRAY may
be used to add default items for the array:

#+name: default array for groups
#+begin_src yaml
  groups:
    header:
      array: true
      default:
        - key: foo1
          value: bar1
        - key: foo2
          value: bar2
#+end_src

** =gid=

OPTIONAL. Exactly like =gid= in the =from=, each group MAY have a
=gid=. Logical groups sharing the same =gid= are in a logical group
themselves, so a nested groups can be defined.

The target data model for nested groups MUST be nested OBJECTs with
related group references unless a NULL LITERAL =target_group= is
specified for the group.

** =events=

OPTIONAL. FRONTEND OPTIONAL. With the same syntax as =events= in the =form= section, each
group MAY have events if the frontend support them.

** Groups Examples

*** Complete groups example

#+name: complete groups example
#+begin_src yaml
  form:
    url:
      name: URL
      description: A valid http/https URL is required
      default: "https://sms.org/v1/"
      type: String
      gid: url
      order: 0
    url_description:
      type: Label
      name: |
        You have to provide the API URL with schema, domain
        and API version.
      gid: url
      order: 1
    template:
      name: Template
      type: String
      gid: template
    template_style:
      name: Template Style
      type: String
      gid: template
    verify_ssl:
      name: Verify SSL
      default: true
      type: Boolean
      gid: ssl_options
    force_ssl:
      name: Force SSL
      default: true
      type: Boolean
      gid: ssl_options
    gateway:
      name: Gateway
      type: String
      array: true
      default:
        - "+983000"
        - "+983001"
      order: 3
    api_user_key:
      name: API User Key
      type: String
      gid: api_key
    api_admin_key:
      name: API Admin Key
      type: String
      gid: api_key
    default_sender:
      name: Default Sender
      type: String
      gid: default_options
    default_receiver:
      name: Default Receiver
      type: String
      gid: default_options
  groups:
    template:
      name: Template Options
      description: |
        You can provide a template for the short messages with
        your desired style.
      target_group: null
      order: 1
    ssl_options: {} # A group with no options will cause the
                    # form values of this group to be stored
                    # in a seperate key.
                    #
                    # Here, it is equivalent to have the
                    # option:
                    #
                    # ssl_options:
                    #   target_group: ssl_options
                    #
                    # This is different than gid "url" which is not
                    # defined here and is equivalent to:
                    #
                    # url:
                    #   target_group: null
    api_key:
      target_group: api
      order: 4
    default_options:
      name: Default Options
      array: true
      default:
        - default_sender: "+98100"
          default_receiver: "+98100"
        - default_sender: "+98200"
          default_receiver: "+98200"
      order: 5
#+end_src

#+name: complete groups result values example
#+begin_src yaml
  url: "https://example.org/v1/"
  template: "Attack from {src} to {dst}"
  template_style: "{}"
  ssl_options:
    verify_ssl: true
    force_ssl: false
  gateway:
    - "+983000"
    - "+983001"
  api:
    api_user_key: "111"
    api_admin_key: "222"
  default_options:
    - default_sender: "+989121234567"
      default_receiver: "+989121234567"
    - default_sender: "+989131234567"
      default_receiver: "+989131234567"
#+end_src

[[./images/groups-complete.png]]

*** Nested groups example

#+name: nested groups examples
#+begin_src yaml
  form:
    url:
      name: Request URL
      type: String
      gid: request
      gorder: 0
    proxy_address:
      name: Proxy Address
      type: STring
      gid: proxy
      gorder: 0
    proxy_username:
      name: Proxy Username
      type: String
      gid: proxy_auth
      gorder: 0
    proxy_password:
      name: Proxy Password
      type: Password
      gid: proxy_auth
      gorder: 1
  groups:
    request:
      name: Request
      array: true
    proxy:
      name: Proxy
      array: true
      gid: request
    proxy_auth:
      name: Proxy Authentication
      target_group: auth
      array: true
      gid: proxy
#+end_src

#+name: nested groups example target data model
#+begin_src yaml
  request:
    - url: "http://example.org/1"
      proxy:
        - address: "proxy:100"
          auth:
            - proxy_username: user1
              proxy_password: pass1
            - proxy_username: user2
              proxy_password: pass2
        - address: "proxy:200"
          auth:
            - proxy_username: ""
              proxy_password: ""
    - url: "http://example.org/2"
      proxy:
        - address: "proxy:300"
          auth:
            - proxy_username: user1
              proxy_password: pass1
#+end_src

[[./images/groups-nested.png]]

* =actions=

Each field or group can have an =events= OBJECT which adds actions for
the events supported by the frontend that SHOULD be executed if the
event occur.

Actions can update the form or call an external service to do some
operations or to provide data for the form itself. Given that the form
may change after executing the action, the form MUST be rendered again
by the frontend after executing the actions.

For example we can use =actions= for an "Advanced Options" button
(e.g. with =type= equal to =Submit=) to add some more fields and
groups to the form:

[[./images/actions-advanced.png]]

Each action in the =actions= section is an ARRAY of OBJECTs. Each
OBJECT in the array define some action keys that are defined
below. The actions for the keys of the OBJECT will be executed with an
unspecified order. But the items in the =actions= array MUST be
executed in the specified order.

** =remove=

The =remove= action defines an arbitrary nested OBJECT with at least
one key referencing any item in the PitayaForm. On execution, the
OBJECT tree MUST be traversed (in an unspecified order) and the leafs
which are references of the items in the PitayaForm has to be removed
from the form.

If the leaf is an empty OBJECT or the NULL LITERAL, its parent is used
as the reference. If the empty or NULL value is an item in an OBJECT,
the referred OBJECT MUST be removed from the PitayaForm.

#+name: empty/null remove action example
#+begin_src yaml
  actions:
    remove_advanced_button:
      form:
        advanced_button: {}
    another_sytnax_for_remove_advanced_button:
      form:
        advanced_button: null
    yet_another_sytnax_for_remove_advanced_button:
      form:
        advanced_button:
#+end_src

The above example defines three actions which all do exactly the
same. They will remove the =advanced_button= key from the =from= key
in the PitayaForm.

If the leaf is not an empty OBJECT or NULL LITERAL and its referred
parent is an ARRAY the first item from the referred ARRAY with the
value of the leaf MUST be removed if it exist. If the parent is an
OBJECT, its key MUST be removed only if its value is equal to the
value of the leaf.

When traversing the remove OBJECT tree, in case of encounter with an
ARRAY, each item in the array could be a separate reference.

** =update=

The =update= action defines an arbitrary nested OBJECT with at least
one key, some of the keys could be options that are defined
below. Other non-option keys MUST be merged into the PitayaForm
OBJECT on execution.

Here is an example which will add =details= and =conditions= keys to
the =form= and =advanced= key to the =groups= section of the
PitayaForm:

#+name: update action example
#+begin_src yaml
   actions:
     add_extra_options:
       - update:
           form:
             details:
               name: Details
               type: String
               gid: advanced
             conditions:
               name: Conditions
               type: String
               gid: advanced
       - update:
           groups:
             advanced:
               name: Advanced Options
               target_group: null
               order: 2
#+end_src

*** =extend_arrays=

OPTIONS. A BOOLEAN which if not present defaults to =false=.

While merging on executing =update=, the defined ARRAYs will replace
the old ARRAYs in the PitayaForm. But with =true= as =extend_arrays=
this behavior could be changed so that the items of the defined ARRAY
MUST be added to the ARRAY in the PitayaForm.

The example below will add a validator to the previous validators of
the =text= field in the =form=.

#+name: update action extend_arrays exmaple
#+begin_src yaml
  actions:
    add_restrictions:
      - extend_arrays: true
        update:
          form:
            text:
              options:
                validators:
                  - hint: Only words are acceptable
                    regex: "^(\w\s)*$"
#+end_src

** =rpc=

The =rpc= action will provide a mechanism to call a remote procedure
on execution. The remote procedure MAY return an extra actions ARRAY
which has to be executed upon the PitayaForm. It can contain =remove=
or =update= or even more =rpc= actions that could be used recursively.

The =rpc= is an OBJECT with the keys defined below.

*** =type=

REQUIRED. The type specifies the RPC type. =http_rest=, =grpc=, =soap= or any
type MAY be supported by the frontend. This document dose not define
specific types but describes an extendable format for all the RPC
methods that could be defined in another specification.

*** =name=

REQUIRED. The name of the remote precedence to be called.

*** =options=

OPTIONAL. An OBJECT which can provide the details a specific RPC type
may require. For example =method= and =content_type= for an
=http_rest= RPC.

*** =async=

OPTIONAL. FRONTEND OPTIONAL. A BOOLEAN which defaults to =false=.

If =async= is =false=, the remote procedure MUST be executed
synchronously. The executor must wait for the result and then continue
the execution of the actions.

If =async= is =true=, the remote procedure MUST be executed
asynchronously. The executor MUST continue the execution of the
actions.

Whenever the asynchronous action returned, the returned value MUST be
used just like the synchronous RPC calls.

*** =arguments=

Each RPC call MAY have arguments that will be defined as an OBJECT in
the =arguments= section in which the keys are the name of the argument
and the value is an OBJECT which defines what have to be passed as the
argument to the remote procedure.

Currently, there are two modes that could be used to provide the value
for an argument: =value= for directly providing the argument data and
=document_reference= for referencing some other part of the PitayaForm
as the input for the argument. These modes are described in detail in
the References and Templates sections of this document.

Here is an example with =value= mode to provide direct data for
arguments. In this example, the =version= is a simple value but
=section= is a template:

#+name: rpc action value argument example
#+begin_src yaml
  actions:
    update_protocols:
      - rpc:
          type: http_rest
          name: get_protocols
          arguments:
            version:
              mode: value   # "value" is the default mode so this line
                            # can be omitted
              type: simple  # "simple" is the default type for "value"
                            # mode and this line can be omitted too
              value: "1"
            section:
              mode: value
              type: jsonpath_braces
              value: "section_{input.section}"
#+end_src

The =document_reference= mode provides a way to reference the desired
value/values from any part of the PitayaForm.

If it is a single value, it will be passed as is. If it as an ARRAY it
SHOULD be passed as an array if the RPC method supports arrays or null
(or null equivalent for the RPC type) if dose not.

In case of a non-existent reference, null (or null equivalent for the
RPC type) MUST be passed as the argument.

Here is an example for =document_reference= mode:

#+name: rpc action value argument example
#+begin_src yaml
  actions:
    update_protocols:
      - rpc:
          type: http_rest
          name: get_protocols
          arguments:
            layers:
              mode: document_reference
              type: jsonpath
              reference: form.layers.options.choices
#+end_src

*** =on_failure=

OPTIONAL. An ARRAY of references to actions that would be executed in
order in case that RPC failed.

A remote procedure call may fail due to network/system errors or it
may support returning error/exceptions.

#+name: rpc action on_failure example
#+begin_src yaml
  actions:
    update_protocols:
      - rpc:
          type: http_rest
          name: get_protocols
          on_failure:
            - show_error
    show_error:
      - update:
          styles:
            error_message:
              hidden: false
#+end_src

*** The successful RPC result

This document dose not include the details for different types of RPC
that could be defined in the =type= section for each =rpc=, but
usually a successful RPC will return some result.

The successful RPC result SHOULD be an ARRAY or it should be converted
to one according to the RPC type specification. Then it MUST be
regarded as an ARRAY of new action OBJECTs that MUST be executed, when
the RPC result is ready. Any errors during the operation of converting
that ARRAY and extracting the actions MUST be ignored silently.

#+name: rpc successful result example
#+begin_src yaml
  - update:
      styles:
        successful_message:
          hidden: false
  - rpc:
      type: http_rest
      name: another_rpc
#+end_src

** =modal=

The =modal= action will provide a mechanism to pop up a modal
form. The modal is an independent form from the main PitayaForm,
although it is also defined according to PitayaForm specification.

The frontend MUST add a close button (for example with an =X= icon on
the title bar) to each modal automatically. Other action buttons can
be added to the form manually.

The =modal= can be used statically in a PitayaForm definition, but
because =rpc= calls can return dynamic actions, using =modal= as a
result of an =rpc= action is a powerful way to have arbitrary dynamic
modal forms to gather input from user in an external form.

The =modal= is an OBJECT with the keys defined below.

*** =title=

OPTIONAL. An optional title for the modal form.

*** =form=

REQUIRED. An OBJECT defining a modal form according to full PitayaForm
specification, with its own =form=, =groups=, =styles=, =actions=,
etc.

Note that references in the modal =form= object are relational to its
root, so it is not possible for a modal form to reference its parent.

#+name: simple modal form example
#+begin_src yaml
  form:
    show_message_button:
      name: Popup
      type: Button
      events:
        - click: popup
  actions:
    popup:
      - modal:
          title: "The modal example"
          form:
            # An independent PitayaForm can be defined here:
            version: "1"
            form:
              note:
                name: Some text on the modal.
                type: Label
#+end_src

** =submit=

The =submit= action can be used to create customized submit
buttons. The =submit= value MUST be according to References and
Templates specification in this document. On execution of this action,
the frontend MUST close the current from and submit the provided value
to the backend.

#+name: submit part of the input with a custom action
#+begin_src yaml
  - submit:
      mode: document_reference
      type: jsonpath
      reference: input.textbox  # submit only part of the input, unlike
                                # the default form submission which the
                                # whole input will be submitted.
#+end_src

More importantly, the =submit= action can be used in the result of an
RPC in a modal form. In this case the =submit= value MUST be
interpreted as actions for the parent form.

#+name: submit in a modal form
#+begin_src yaml
  - update:  # this action will be executed in the modal form itself
      styles:
        foo:
          hidden: false
  - submit:
      mode: value
      type: simple
      value:
        - update:  # this action will be executed on the parent form
            styles:
              bar:
                hidden: false
#+end_src

** Actions examples

*** Advanced options

#+name: advanced options example
#+begin_src yaml
  form:
    title:
      name: Title
      type: String
    extra_options:
      name: Advanced Options
      type: Submit
      events:
        - click: add_extra_options
   actions:
     add_extra_options:
       - remove:
           form:
             extra_options: {}
       - update:
           form:
             details:
               name: Details
               type: String
               gid: advanced
             conditions:
               name: Conditions
               type: String
               gid: advanced
       - update:
           groups:
             advanced:
               name: Advanced Options
               target_group: null
               order: 2
       # The actions above will be peformed in the specified order. This
       # was only to illustrate an example. In practice, first "remove"
       # and "update" my combined together and the last "update" could
       # be removed and the "groups" secton could be added statically,
       # as groups with no objects should do nothing.
#+end_src

[[./images/actions-advanced.png]]

*** Add/Remove validators

#+name: add/remove validators example
#+begin_src yaml
  form:
    text:
      name: Text
      type: String
      gid: txt
    restrict:
      name: Add Restrictions
      type: Submit
      events:
        - click: add_restrictions
      gid: txt
    unrestrict:
      name: Remove Restrictions
      type: Submit
      events:
        - click: remove_restrictions
      styles:
        hidden: true
      gid: txt
   actions:
     add_restrictions:
       - remove:
           form:
             restrict:
       - update:
           extend_arrays: true
           form:
             text:
               validators:
                 - hint: Only words are acceptable
                   regex: "^(\w\s)*$"
           styles:
             restrict:
               hidden: true
             unrestrict:
               hidden: false
     remove_restrictions:
       - update:
           form:
             text:
               validators: []
           styles:
             restrict:
               hidden: false
             unrestrict:
               hidden: true
#+end_src

[[./images/actions-rpc-validators.png]]

*** One Time Password

#+name: one time password example
#+begin_src yaml
  form:
    password:
      name: Password
      type: Password
    send_password:
      name: Send One Time Password
      type: Submit
      events:
        - click: send_password
   actions:
     send_password:
       - rpc:
           type: http_rest
           name: send_otp
           arguments:
             user_id:
               external:
                 external_id: init_args
                 key: user_id
#+end_src

[[./images/actions-rpc-one-time-passowrd.png]]

#+name: one time password rpc successful results example
#+begin_src yaml
  - update:
      result:
        password: ...
#+end_src

*** Static choices

#+name: add/remove choices example
#+begin_src yaml
  form:
    country:
      name: Countries
      type: Choices
      options:
        choices:
          iran: {"name": "Iran"}
          afghanistan: {"name": "Afghanistan"}
        multiple: true
      events:
        click:
          - update_cities
    city:
      name: Cities
      type: Choices
      events:
        initialize:
          - update_cities
  actions:
    update_cities:
      - rpc:
          type: js
          name: get_cities
          arguments:
            countries:
              mode: document_reference
              type: jsonpath
              value: input.country

  js: |
    function get_cities(countries) {
      return [
        {"update": {"form": {"city": {"options": {"choices":
          Object.assign({}, ...countries.map(
              country => (
                  {"iran": {
                      "tehran": {"name": "Tehran"},
                      "esfahan": {"name": "Esfahan"}},
                   "afghanistan": {
                       "kabul": {"name": "Kabul"},
                       "herat": {"name": "Herat"}}}[country])))}}}}}];
    }
#+end_src

#+begin_src js
#+end_src

[[./images/actions-static-choices.png]]

*** RPC Choices

#+name: RPC choices example
#+begin_src yaml
  section:
    name: Network Section
    type: String
  layers:
    name: Layers
    default:
      - transport
      - application
    type: Choices
    options:
      choices:
        network: {"name": "Network Access"}
        internet: {"name": "Internet"}
        transport: {"name": "Transport"}
        application: {"name": "Application"}
      multiple: true
    events:
      click:
        - set_protocols
  protocols:
    name: Protocols
    type: Choices
  actions:
    set_protocols:
      - rpc:
          type: pitaya_command
          name: get_protocols
          arguments:
            section:
              template: true
              value: "section_{input.section}"
            network_layers:
              mode: document_reference
              type: jsonpath
              reference: input.layers
#+end_src

#+name: RPC choices result example
#+begin_src yaml
  - update:
      form:
        protocols:
          options:
            choices:
              tcp: {"name": "TCP"}
              udp: {"name": "UDP"}
              http: {"name": "HTTP"}
              ssh: {"name": "SSH"}
              ip: {"name": "IP"}
              icmp: {"name": "ICMP"}
#+end_src

[[./images/actions-rpc-choices.png]]

*** EULA modal

#+name: EULA modal example
#+begin_src yaml
  form:
    agreed:
      name: I agree with the terms and conditions
      type: Boolean
      events:
        - click: show_eula
  styles:
    agreed:
      read_only: true
  actions:
    - rpc:
      type: js
      name: show_eula
  js: |
    function show_eula() {
      return [{
        "modal": {
           "title": "Do you agree with the EULA?"
           "form": {
             "version": "1",
             "form": {
               "eula": {"name": "Terms ... and Conditons ...",
                        "type": "Label"},
               "i_agree": {"name": "Yes, I agree",
                           "type": "Button",
                           "events": [{"click": "yes"}]}},
             "actions": {
               "yes": [
                 {"submit":
                   "value": [{"update": {"input": {"agreed": true}}}]
                 }]}}}}];
    }
#+end_src

[[./images/actions-rpc-modal-eula.png]]

*** Customized modals with RPC

This is a more sophisticated form of using RPC to generate custom
modal forms for customized user input, although for brevity the RPC
implementation is not included. Instead an example of what the RPC
method may return is presented.

This example, also illustrates the use of =current_reference=
reference mode. Each "edit" button in the array should pop up a modal
for the selected item in the array, so some way to reference the
current selected item is required.

#+name: customized modals with RPC example
#+begin_src yaml
  form:
    add_activity:
      name: null
      type: Choices
      options:
        choices:
          empty: {"name": ""}
          notification: {"name": "Add new notification"}
          log: {"name": "Add new log"}
      events:
        - click: new_activity
    activity_name:
      type: Label
      gid: activities
    activity_edit:
      name: null
      type: Button
      gid: activities
      events:
        - click: edit_activity

  groups:
    activities:
      array: true

  styles:
    activity_edit:
      icon: edit
    activities:
      insertable: false
      removable: true

  actions:
    new_activity:
      - rpc:
          type: http_rest
          name: activity
          arguments:
            activity_type:
              mode: document_reference
              type: jsonpath
              reference: input.add_activity
            activities:
              mode: document_reference
              type: jsonpath
              reference: input.activities  # array
            item_reference:
              mode: value
              value: null
    edit_activity:
      - rpc:
          type: user_input
          name: activity
          arguments:
            activity_type:
              mode: value
              value: null  # this is an edit and whatever activity type
                           # the item has, it should be preserved (the
                           # activity type cannot be edited)
            activities:
              mode: document_reference
              type: jsonpath
              reference: input.activities  # array
            item_reference:
              mode: current_reference

#+end_src

[[./images/actions-rpc-modal-activities.png]]

The above =activity= RPC should accept three arguments:
-  =activity_type= :: Can be "notification" or "log" which will
  determine what kind of "modal" form should be generated. The NULL
  LITERAL is also acceptable to open an edit modal form for an already
  created activity in the array.
- =activities=: An array of all the existing activities in the parent
  form.
- =item_reference=: The NULL LITERAL for new activities or a STRING
  reference e.g. =activities[3].activity_edit= for edits, which can be
  used to determine which activity in the array should be edited.

Then the RPC should return a =modal= action to pop-up the related from
according to its arguments. For example, if the user selects the
=notification= item in the =add_activity= choices to add a new
notification activity, the RPC may return this to pop-up a modal to
ask for more details from the user:

#+name: example modal action returned by the RPC
#+begin_src yaml
  - modal:
      title: "Enter the notification details"

      form:
        notification_type:
          name: via
          type: Choices
          options:
            email: {"name": "Email"}
            sms: {"name": "SMS"}
        receptor:
          name: Receptor
          type: String
        add_notification_button:
          name: Add Notification
          type: Button
          gid: buttons
          events:
            - add_notification
        cancel_button:
          name: Cancel
          type: Button
          gid: buttons
          events:
            - cancel

      actions:
        add_notification:
          - rpc:
              type: http_rest
              name: add_notification_to_parent_form
              arguments:
                input:
                  mode: document_reference
                  type: jsonpath
                  reference: input # the whole modal form input
        cancel:
          - submit:
              # submiting no actions to the parent will close the modal
              # without any changes in the parent form.
              value: []
#+end_src

Note that the modal form action in the above example has its own
actions. The =add_notification= action in the modal form will call
another RPC =add_notification_to_parent_form= which should accept the
input from the modal form and should generate a =submit= action itself
to update the parent form's =input= with a new item in its
=activities= array.

* =input=

The =input= section in a PitayaForm represents the frontend generated
target data model according to the current entered values by the
user. As user change the inputs the values in the =input= MUST be
updated. The =input= is useful to be referenced from other sections of
the form.

On the form initialization, the frontend MUST create an input object
by using the default values in the =form= and =groups=. Then if there
exists an =input= section in a PitayaForm it MUST be merged into the
created input object overriding the default values. The merge MUST be
done just like the =update= action with =extend_arrays= set to
=false=. Finally the object MUST be set as the =input= of the
PitayaForm and updates according to user input.

Here is an example with a form with three fields. The =host= is a
required String with a validator to make sure it has at least one
character. On the other hand =port= and =flag= are optional Number and
Boolean which have default values:

#+name: a form without input example
#+begin_src yaml
  form:
    host:
      type: String
      options:
        validators:
          - regex: ".+"  # at least one character
    port:
      type: Number
      default: 80
    flag:
      type: Boolean
      default: false
#+end_src

On initialization a FRONEND has to create an =input= OBJECT with
default values: ={"port": 80, "flag": false}=. As no =input= is
present in the above example the =input= object will added to the
PitayaForm intact by the FRONEND:

#+name: the example form after initialization
#+begin_src yaml
  form:
    host:
      type: String
    port:
      type: Number
      default: 80
    flag:
      type: Boolean
      default: false
  input:
    port: 80
    flag: false
#+end_src

Note that the =input= is not acceptable as the final output, because
it dose not have the required =host= field, nevertheless it will be
generated temporarily so it can be referenced by other parts of the
PitayaForm.

A form may have the =input= field while it is submitted to the
frontend. The next example has an =input= with =flag= key on
submission to the frontend:

#+name: a form with input example
#+begin_src yaml
  form:
    host:
      type: String
    port:
      type: Number
      default: 80
    flag:
      type: Boolean
      default: false
  input:
    flag: true
#+end_src

This time, the submitted =input= will be merged and override the
values generated from the defaults, on initialization:

#+name: the example form after initialization
#+begin_src yaml
  form:
    host:
      type: String
    port:
      type: Number
      default: 80
    flag:
      type: Boolean
      default: false
  input:
    port: 80
    flag: true
#+end_src

* References

** Document Reference

For a variety of reasons it may be necessary to refer to a point in
the PitayaForm. In some cases the reference is always from a specific
point. For example, a key inside =groups= is a reference to a =gid= in
a field of a form. In these cases reference with just one name is
sufficient.

There are cases where it is necessary to refer to an arbitrary
location of the whole PitayaForm. For example, a =remove= action or an
=rpc= may require an arbitrary location from any element in the
PitayaForm.

For arbitrary references, there may exist different methods with
different flexibility, simplicity and brevity. To exploit all these
methods, PitayaForm uses an object reference with three keys: =mode=,
=type= and =reference=.

The =mode= must be the literal =document_reference= which means this
is a reference to the current document.

The =type= determines which reference method SHOULD be used and the
=reference= determines the reference itself according to the method.

This document will not specify which reference types should be
supported, so a frontend MAY support different types. In case of an
unsupported =type=, a frontend MUST assume NULL LITERAL as the
referent.

For example a frontend MAY support [[https://goessner.net/articles/JsonPath/][jsonpath]], so a reference could be:

#+name: jsonpath reference example
#+begin_src yaml
  mode: document_reference
  type: jsonpath
  reference: input.headers[0].value
#+end_src

** Current Reference

If an =rpc= action is triggered by an event from an item in an array
there should be someway for the RPC implementation to determine which
item of the array has triggered the action.

The =mode= equal to =current_reference= should generate a reference to
the triggered action. If no triggered action is available in the
context, NULL LITERAL MUST be generated.

The =type= will determine what syntax should be used for the
reference. For example, =jsonpath= might with dot notation and
brackets for array indexes might be used.

#+name: RPC calls triggered by the items in the array example
#+begin_src yaml
  form:
    books:
      name: Book Name
      type: String
      array: true
      events:
        - change: process_book
    author_id:
      name: Author ID
      type: Number
      gid: authors
    author_name:
      name: Author Name
      type: String
      gid: authors
    author_submit:
      name: Submit Author
      type: button
      gid: authors
      events:
        - click: process_author
  groups:
    authors:
      array: true
  actions:
    process_book:
      - rpc:
        type: http_rest
        name: process_book
        arguments:
          all_books:
            mode: document_reference
            type: jsonpath
            reference: input.books  # array of all book names
          book_ref:
            mode: current_reference  # For example, if the 4th item in
                                     # the array has triggerd this
                                     # action, "books[3]" will be set as
                                     # the value for "book_ref"
                                     # argument
    process_author:
      - rpc:
        type: http_rest
        name: process_book
        arguments:
          all_authors:
            mode: document_reference
            type: jsonpath
            reference: input.authors  # array of all the authors
          author_ref:
            mode: current_reference  # For example, if the 7th item in
                                     # the array has triggerd this
                                     # action,
                                     # "authors.author_submit[6]" will
                                     # be set as the value for
                                     # "author_ref" argument
#+end_src

* Templates

In a PitayaForm, it may be desirable to specify values based on other
values in the form. For example, the value of an =rpc= argument may
need to be some literals concatenated with a value from the =input=.

Therefore, it is necessary to support templates with references. As
stated in References section, there are several references types that
a frontend may support. This is exactly the same for templates. Just
like references, the supported template types will not be restricted
in this document, but a general method for using different types of
templates in the values of a PitayaForm is described.

There SHOULD be three keys for a value: =mode=, =type= and
=value=. The =mode= must be the literal =value= which means it is a
value and not a direct reference.

If it is a fixed value, the =type= must be =simple= and the =value= key
determines the value itself.

#+name: an example for a fixed value
#+begin_src yaml
  mode: value
  type: simple
  value: "some value"
#+end_src

The default value for =mode= MUST be considered =value= and the
default value for =type= MUST be considered =simple=. So a shorter
version of the previous example is:

#+name: brief fixed value example
#+begin_src yaml
  value: "some value"
#+end_src


Other values for =type= can determine the type of the template. In
this case, the =value= is the template itself that may have references
to other locations in the PitayaForm according to its type.

Here is an example for a template:

#+name: jsonpath_braces template example
#+begin_src yaml
  # the default "mode" is "value"
  type: jsonpath_braces
  value: "prefix_{input.headers[0].value}_suffix"
#+end_src

* Authors

Mohammad Razavi <mrazavi64 at gmail dot com>

#+STARTUP: inlineimages
